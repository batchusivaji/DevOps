## DevOps
    A DevOps engineer will work with development staff to tackle the coding and scripting needed to connect elements of code, such as libraries or software development kits (SDKs), and integrate other components such as SQL data management or messaging tools that are needed to run the software release on operating systems.

## The tasks of the DevOps engineer might vary based on the area which he is focussing on
---
#### For infrastructure position :
     He will have a responsibility to automate the infrastructure provisioning and writing recipes for creating the necessary infrastructure needed for the application teams. He might also help in automating the patching process and also take part in the infrastructure refresh.

#### For the Build and Deployment Position :
     He will responsible to creating the delivery pipeline which will help to propagate the code from one environment to another. He will also play a support role in supporting the delivery pipeline and try to integrate more tools into the pipeline

#### For monitoring position :
    this corresponds to creating the necessary dashboards for application and infrastructure monitoring and also creating the self heal routines which are necessary to send in the proactive alerts to the necessary consumers.

---

## DevOps Engineer daily activities :

---
* Writes code/software.In fact, he is a proper software engineer
* Builds tools. Does the painful things, as often and frequently as possible.
* Participates in the on-call rotation
* Infrastructure design.
* Scaling systems (any system or subsystem - networking, applications, load balancers).
* Maintenance like rebooting that frail vhost with a memory leak that no one’s bothered to fix or take ownership of
* Monitoring
* Virtualization
* Agile/kanban/whatever development methodology. It’s not so much that agile is “right.” It’s just the most efficient way to complete a work queue (taking into account interruptions and blockers). A good DevOps engineer has strong opinions about this!
* Software release cycles and management. In fact, you might even see “development methodology” and software release cycles as the same thing.
* Automation. Automation. Automation.
* Designing a branch/release strategy for the provided SCM (git, Mercurial, svn, etc). Which you do have.
* Metrics / reporting. Goes hand-in-hand with monitoring, although they are different.
* Optimization / tuning. Of applications, tools, services, hardware…anything.
* Load and performance testing and benchmarking, including performance testing of highly complex systems. And you know the difference between load testing and performance testing.
* Cloud. Okay, you don’t really have to have cloud experience, but it can fundamentally change the way you think about complex systems. No one in a colo facility devised the notion of “immutable infrastructure.”
* Configuration management. Or not. You have an opinion about it. (You’ve surely heard of Puppet, Chef, Ansible, etc. Yes?)
* Security. At every layer.
* Load balancing / proxying / replicating. (Of services, systems, components and processes.)
* Command-line fu. A DevOps engineer is familiar with tools at his disposal for debugging, diagnosing and * * * fixing issues on one or many servers, quickly. You know how pipes work, and you can count how many records * * contained some phrase in a log file with ease, for example.
* Package management.
* CI/CIT/CD — continuous integration, continuous integration testing, and continuous deployment. This is the * * closest thing to the real meaning of “DevOps” that a Systems Engineer will do.
* Databases. All of them. SQL, NoSQL, whatever. Distributed ones, too!
* Solid systems expertise. We’re talking about the networking stack, how hard disks work, how filesystems work,* how system memory works, how CPU’s work, and how all these things come together. This is the traditional “operations” expertise you’ve heard about.

---

